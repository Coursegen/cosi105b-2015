
var tipuesearch = { "pages": [

        {"title": "chalkmark", "text": "function handle_helpful_link(yesno) { $.ajax({ url:  http://chalkmark.herokuapp.com/api/helpful/vote/ , data: {url: document.title, value: yesno}, dataType:  jsonp , success: function(data) { display_visit_stats(data); }} )}; function display_visit_stats(response) { yes_votes = response.true; no_votes = response.false; if (yes_votes > 0 || no_votes > 0) { $( #helpful ).addClass( text-center ).html( votes so far: Yes:   + response.true +   No:   + response.false +   ); } } $( #yes-link ).click( function() { handle_helpful_link( yes );}); $( #no-link ).click( function() { handle_helpful_link( no );}); function record_visit() { $.ajax({ url:  http://chalkmark.herokuapp.com/api/helpful/visiting/ , data: {url: document.title}, dataType:  jsonp , success: function(data) { display_visit_stats(data) }} )}; $(function() { record_visit(); }); ", "tags": "", "loc": "/chalkmark/chalkmark.js" },

        {"title": "Welcome!", "text": " Software Engineering and Architecture At Scale Learn how large software teams build large systems. How does programming change when a system has thousands of modules and dozens of programmers? How do you ensure that the systems you build can evolve and grow? How do you put together an architecture that will survive an onslaught of 500,000 users or more? This course introduces you to concepts, principles, techniques and research that try to answer those questions. Pito Salas, pitosalas@brandeis.edu Scale What happens when systems have programs in multiple languages, hundreds of modules and classes, developed by teams of engineers? We need to approach programming in a whole new way, paying attention to good design, patterns, testing, source code management and other basics. In addition when software is developed in teams there are ways of approaching organization of the project, leadership, planning and scheduling. How do you design a system that is meant to support millions of users? How will it perform? You certainly can’t just get a bigger and bigger computer. This is most certainly an evolving space with new work happening both in academia and industry. Yet there are well established and tested fundamentals of architecture which we will look at to better understand this fascinating and important space. Programming There will be multiple programming assignments where students will work individually or in teams to modify and enhance parts of the NanoTwitter software. Students will have to build and test on their own computers and then deploy software to servers in the cloud. We will subject the software to artificial loads to see how they behave and then see how changes affect performance. Prerequisites and admission Prerequites for this course is that you have taken Cosi 12b and/or 21a. For more information contact Pito Salas, pitosalas@brandeis.edu ", "tags": "", "loc": "/" },

        {"title": "Nano Twitter Functionality", "text": "NanoTwitter (nt) is a baby version of Twitter designed as a platform for experimentation with scaling issues. Functionality Users: can register for an account by supplying an email and a password are never deleted Logged in users Can follow and unfollow other registered users Can tweet Can see the flow of the last n tweets by the users that they have followed Non-logged in users See the flow of the last n tweets by any user Tweets Consist of a 140 characters of text a date-time of creation Belong to one user Can never be deleted REST Api is provided Retrieve the firehose of all tweets by all users Retrieve the firehose for one specific user User Interface Very basic bootstrappy html interface Non-logged-in root page (/) Login link (/login) Register for account link (/user/register) List of the most recent  n  tweets, with link to tweeter’s page Logged-in root page (/) Logout link (/logout) Box to submit a tweet (/tweet) List of most recent ‘n’ tweets, with link to the tweeter’s page Specific user’s page (/user/2345) List of users tweets Button to follow that user (available only if logged in) API REST-y API All paths start with /api/v1 /tweets/23 - return tweet with id /users/23 - return user information for user 23 /tweets/recent - return the recent n tweets /users/23/tweets - return the users recent tweets Values as JSON Tweet: {  id : 123,  text : foobar,  created : jan-11-2015 } User: { id : name : Pito Salas} List of tweets: [<tweet>, <tweet>,...] Follow list: [ user_id : 22,  user_id : 23, ...] ", "tags": "", "loc": "/content/nt/01_nt_functionality/" },

        {"title": "NT Design and Architecture", "text": "The objective of the NT project is to give students hands-on experience designing a simple system which will expose and exercise issues of scale. Architecture The  spec  for NanoTwitter doesn’t dictate anything about the architecture other than it be reached via a url. It has two kinds of access, through a web browser (for human access) and as a REST service (for access from other applications). Deployment NT will be deployed as a service in the cloud. Our base case is to use Heroku but again there are other variations that are possible which are equally valid. Language and framework The base case would be to implement NT using Ruby and Sinatra. We will cover those in the class. But there are other languages and platforms that could be used as easily, for example Node.js with Express. There are others. We will discuss this possibility in class. Testing The NT code will have automated unit test that can be run at will to check for new bugs. The base case will be to use ruby’s minitest package. Logging and performance The NT code will need to incporate instrumentation to be able to monitor its performance and detect bottlenecks and other problems. The base case will be to use newrelic. ", "tags": "", "loc": "/content/nt/02_nt_arch/" },

]};